# x86

intel的段机制是从8086开始的, 目的是为了解决cpu 16位地址到20位实地址的转换. 为了向下兼容, x84仍使用了段机制, 但比8082更复杂. xv6和linux类似, 均未完全采用intel提供的段机制, 仅仅非常有限地使用了分段机制.

## 保护模式和段寄存器
32位保护模式下逻辑地址和线性地址的转换按照分段机制完成. 该过程较为复杂, 涉及描述符, 描述符表, 选择符和任务状态段这4种数据结构以及段寄存器, 任务寄存器和系统地址寄存器, 控制寄存器和标志寄存器.

分段机制看起来很复杂, 其核心是描述符表.

### 描述符和描述符表
一个描述符共64位, 由12位段属性, 32位段基址和20位段界限构成.

描述符表用于存储描述符, 是描述符构成的数组.

3个描述符表:
1. 全局描述符表GDT

    GDT中的第一个条目，索引为0。根据x86规范，索引为0的条目必须是空描述符（Null Descriptor）。它通常被全零填充，用于捕获对空段选择子的非法使用

    一个系统只有一个GDT, 可以包含:
    1. 全局的数据段, 代码段, 堆栈段描述符
    2. LDT描述符, 其基址是LDT在内存中的起始位置
    3. TSS描述符, 其基址是TSS所在内存中的起始位置
    4. 一些门描述符(调用门, 中断门等)

1. 中断描述符表IDT, 每个表项称为一个门描述符

    每一项对应一个中断门, 陷阱门或任务门, 每个门描述符由8B组成, 最多需要256*8=2048B来存放IDT. 每个描述符包含一个中断处理程序的入口地址, 在中断系统中用中断号来索引IDT, 得到中断处理程序的段选择符和偏移量, 段选择符在相应的描述符表中得到中断处理程序的基地址.

1. 局部描述符表LDT, 每个任务可以有一张. 该表被当作一个段来管理. xv6未使用LDT

    与GDT的结构类似, 但LDT用来描述每个具体用户任务代码段, 堆栈段和数据段信息. LDT是针对每个用户任务的, 类似TSS这样的全局信息相关的描述符只存在于GDT中. LDT描述项一般和正在运行的用户任务数相等. 每个用户任务都可能有自己的LDT, 保持本任务相关信息. LDT的基址作为一条记录保存在GDT中. xv6未使用LDT.

    现在的操作系统（包括xv6、Linux和Windows）不使用LDT的主要原因:
    1. 现代分页机制取代了分段

        分页提供了比分段更灵活、更精细的内存保护和管理方式. 但LDT的设计是为了给每个进程提供一组独立的段，但它仍然基于分段模型，这在现代多任务环境中显得繁琐和低效.
    1. LDT的复杂性与管理开销

        每个进程拥有自己的LDT，这引入了额外的管理开销
    1. 全局描述符表（GDT）的足够性

        GDT在现代os中通常只包含少量的、用于全局目的的段描述符. 通过这种方式，所有进程都共享相同的 GDT 描述符来访问内核和用户空间。这避免了为每个进程创建新的段，简化了内存管理。当一个进程需要切换到内核时，它只需要使用 GDT 中的一个预定义好的段描述符，而不需要加载任何 LDT.

    尽管分段和LDT是x86架构的一个强大特性，但在分页机制出现后，它们变得不再必要。现代操作系统选择了更简单、更灵活、性能更高的分页来管理内存。因此，LDT被弃用，而GDT则被简化为仅包含那些在整个系统中共享的、必要的段.

为访问描述符表中的描述符, 需要描述符表的地址和索引. GDT, LDT和IDT的地址分别由GDTR, LDTR和IDTR来存储. IDT由8位的中断向量号来索引, GDT和LDT由16位的段选择符的高13位来索引, GDT和LDT由段选择符的TI位来区分. 段选择符用段寄存器或LDTR或任务寄存器TR的16位可见部分来存储. TR保存TSS的段选择符.

系统段描述符包括LDT的描述符和TSS描述符.
门描述符包括调用门/中断门/陷阱门/任务门描述符. 门用于任务转换, 实现从一个任务进入另一个任务; 门描述符则描述了门的属性(如特权级, 段内偏移量等)

xv6未使用调用门描述符. 调用门用于在不同特权级间实现受控的程序控制转移, 通常仅用于使用特权级保护机制的os中. 调用门描述符可以放在GDT和LGT中, 但不能放在IDT中.

### 系统地址寄存器
系统地址寄存器存放描述符表地址, 包括:
- 全局描述表寄存器GDTR（Global Descriptor Table Register ）

    gdtr是一个48位的寄存器，高32位用来存放段描述符地址，低16位用来存放段描述符的界限.
- 局部描述表寄存器LDTR（Local Descriptor Table Register ）, **现代处理器未使用ldtr**.

    LDTR=16位段选择符(可见) + 64位描述符(不可见)
- 中断描述表寄存器IDTR

    IDTR = 一个48位的寄存器, 32 位基地址和 16 位表长度值

    指令 LIDT 和 SIDT 分别用于加载和保存 IDTR 寄存器的内容. 在机器刚加电或处理器复位后，基地址被默认地设置为 0，而长度值被设置成 0xFFFF.

> GDTR和IDTR也成为系统表寄存器; TR和LDTR称为系统段寄存器.

### 段选择符和任务寄存器
16位段选择符 = 13位描述符表索引(最多8192个描述符) + 1位TI(table indicator) + 2位RPL构成, 用于索引描述符表GDT和LDT, 可用6个段寄存器CS, DS, ES, FS, GS和SS之一存放.

RPL(Requested Privilege Level): 表示以什么样的权限去访问段, 用于特权检查.

RPL用法如下: 每当程序试图访问一个段时, MMU把当前特权级与所访问段的特权级进行比较, 以确定是否允许程序访问该段. 使用段选择符的RPL将改变特权级的检查规则, 在这种情况下, 与所访问段的特权级比较的特权级不是CPL, 而是CPL和RPL中更外层的特权级, 这样高特权级的代码可以用低特权级来访问其他段. 有些情况下高特权级的代码需熬访问低特权级的空间, 但是不需要以高特权级的身份访问, 以保护被访问空间的安全性. RPL为这种情况提供了可能, 比如当前CPL=0的内核代码要访问一个用户数据段, 如果把段选择符中的RPL设为3, 这样它对该段仍然只有特权为3的访问权限.

调用者设定的RPL是不可靠的, 为了防止调用者以调用函数的高特权级来访问其余数据段, 内核的函数得到调用者的RPL后, 需要检查其RPL并用相关指令进行调整.

TSS(任务状态段)是一种特殊的用于记录任务的寄存器等信息的段, 是在GDT中描述的, 是内存中的一种数据结构, 它保存与任务相关的信息. 当运行的任务准备切换时, cpu会把当前任务用到的寄存器内容和LDT的选择符等信息保存在TSS中以便任务切换回来时继续使用.

TSS主要分为:
1. 动态字段

    在任务切换过程中当任务挂起时, 处理器会更新动态字段:
    1. 通用寄存器字段: 任务切换前的eax, ecx, edx, ebx, esp, ebp, esi, edi
    1. 段选择符字段: 任务切换前的es, cs, ss, ds, fs, gs
    1. eflags字段: 任务切换前的eflags
    1. eip字段: 任务切换前的eip
    1. 先前任务链接字段: 包含先前任务的TSS的段选择符. 该字段禁止任务通过使用iret返回先前的任务
2. 静态字段

    当任务创建时会创建静态字段, 静态字段可读不可写:
    1. LDT段选择符字段: 包含任务LDT的段选择符
    1. CR3字段: 包含任务使用的页目录的物理基地址
    1. 特权级0,1,2栈指针字段: 包含栈段(因为任务运行在不同特权级下, 需要不同的栈段, 因此包含相应的ss0,ss1,ss2)的段选择符的逻辑地址和栈的偏移(不同特权级相应的esp0, esp1, esp2). 在特定的任务中该字段是静态的, 但如果栈切换发生在单个任务中, ss和eip的指就会改变
    1. t标志(调试陷阱): 如果设置则当切换任务时会引起调试异常
    1. I/O许可位图偏移: 指明I/O许可位图相对于TSS起始的偏移

对于多任务os来说, TSS是必不可少的, 系统至少需要一个TSS, 但是由于TSS提供的硬件级进程切换机制复杂且效率低下, 现代os(包括linux和xv6)很少使用TSS机制来进行任务切换, 而仅仅使用TSS来提供0~2权限级别的堆栈指针, 因为当发生堆栈切换时, 必须依靠TSS提供的相应的堆栈指针. 当前进程要切换到另一个进程时, 可以使用两种选择符进行: 使用TSS选择符以及任务门选择符.

cpu在GDT中查找到一个任务门选择符, 它指明了目标的TSS选择符. cpu从任务门选择符中加载TSS描述符, 剩下的工作和使用TSS描述符进行切换进程是一致的. 处理器访问任务门选择符仅需要对任务门选择符做如下权限检查: CPL<=DPL并且RPL<=DPL. 此时不需要对任务门选择符的DPL进行检查. 门描述符机制提供了一个间接访问层, 主要用来控制权限的切换.

任务寄存器TR用于存放GDT中的一个16位TSS选择符, 该TSS被称为当前TSS.

6个段寄存器CS, DS, ES, FS, GS和SS中, 每个都包括16位可见部分和64位不可见部分(描述符高速缓存器, Descriptor, cache register), 可见部分存放段选择符, 不可见部分缓存描述符. 其中CS指向GDT或LDT的代码描述符, DS, ES, FS, GS和SS指向GDT或LDT的数据描述符.

任务状态段是由26个32位整数构成的一个表, 主要保存CPU的寄存器. 该表被当作一个段来管理, 由系统描述符中的TSS描述符来描述.

### 逻辑地址到线性地址
逻辑地址到线性地址由cpu mmu的分段单元自动完成, 过程如下:
1. 段选择符的TI位是0或1, 表示了当前要转换的是GDT(TI=0)还是LDT(TI=1)中的段, 再根据GDTR和LDTR得到GDT或LDT表的基地址
1. 通过段选择符中的索引(15~3位)在表中查到对应的描述符, 得到段的基地址
1. 计算线性地址

### 段的特权等级保护
特权等级保护是os安全稳定的需要, 为了安全稳定需要将os和用户程序分开. 现代os(包括linux, xv6)只使用0(kernel)和3(user)两种特权级. x86通过CPL/RPL/DPL以及代码段描述符中的一致代码位C来管理特权等级:
1. CPL(当前特权级): CPL在寄存器如cs中
1. RPL(请求特权级): RPL在段选择符中的最后2位, 代码中根据不同段跳转而确定, 以动态刷新cs中的CPL
1. DPL(描述符特权级): DPL在GDT/LDT中, 是静态的. GDT/LDT中的每个描述符被设置不同的特权级. 程序通过选择符/门调用等在段之间来回转移, 实现用户级和系统级的调用跳转.
1. C=1, 一致代码段. 一致代码段是可以被低特权级的用户直接调用访问的共享代码. 通常这些共享代码是不访问受保护的资源的代码和某些类型的异常处理. 例如一些数学计算函数库只为纯粹的数学计算, 被作为一致代码段. 一致代码段特权级高的程序不允许访问特权级低的数据, 内核态不允许访问用户态的数据; 特权级低的代码可以访问特权级高的数据, 但是特权级不会改变.
1. C=0, 非一致代码段. 为了避免低特权级的访问被内核保护起来的系统代码, 非一致代码只允许同级间访问

x86的特权级机制过于复杂, xv6做了简化, 选择符的RPL总是等于其索引的描述符的DPL, 内核的代码段为非一致代码段.

程序控制权从一个代码段转移到另一个代码, 目标代码段选择符必须加载进cs中. 加载时cpu首先检查目标代码段的描述符并执行限长, 类型和特权级检查. 检查通过后, 目标代码段选择符就会加载进cs, 程序的控制权就被转移到新的代码段中, 程序将从eip指向的指令处开始执行.

程序的控制转移由jmp, ret, call和iret以及异常和中断机制来实现. 不通过门描述符进行段间转移加载新的段选择符, 需要进行相应的特权级保护检查.
不通过门与通过门进行段间转移的区别在于前者要区分一致性和非一致性代码段, 对非一致性代码段DPL, 要求DPL=CPL, 但xv6未使用该机制.

对于xv6, 代码段只有内核代码段和用户代码段, 代码段间的转移只有以下几种情况:
1. 实模式到保护模式
1. 用户态因硬件中断, 异常和系统调用进入内核态
1. 中断处理完成, 从内核态返回用户态

#### 特权级变化的堆栈切换
调用门用于把程序转移到一个更高级别的非一致性代码段, 转移时cpu会自动切换到目标代码段特权级堆栈中去, 以防止低特权级程序通过共享的堆栈破坏高特权级的程序, 也防止高特权级程序由于展空间无效而引起奔溃. 原先的堆栈段指针会被压入新的栈, 在调用或者中断返回时恢复原来的堆栈.

一个特权级3的程序如果需要切换到其他特权级, 需要设置相应的栈. x86有4个特权级, 因此每个任务最多需要定义4个栈, 但现代os仅使用0和3, 因此只需要2个栈, 每个栈位于不同的段中, 通过段选择符和偏移来设定栈的位置. 特权级0,1,2的堆栈的初始指针都存放在当前运行任务的TSS中, 又因xv6未使用特权级1和2, 因此只需要设置特权级0的堆栈, xv6将其设置为进程的内核堆栈.

TSS中这些指针在任务运行时cpu并不会修改它们. 每次从低特权级进入高特权级切换堆栈时, cpu会使用TSS来建立新的堆栈, 供该特权级的代码使用, 原先特权级的ss和esp会被保存到新的堆栈; 从高特权级返回低特权级时, 低特权级的ss和esp被从高特权级的堆栈中恢复. 内核需要负责为所有用到的特权级建立堆栈和堆栈描述符, 并且在任务的TSS中设置栈指针值.

### xv6
```c
// --- GDT, proc.h
struct segdesc gdt[NSEGS];   // x86 global descriptor table
// --- IDT, trap.c
struct gatedesc idt[256];
```